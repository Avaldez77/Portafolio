
import asyncio
import re
import os
from datetime import datetime, timedelta
from playwright.async_api import async_playwright, expect, TimeoutError as PWTimeout

# Optional (for Outlook desktop email)
try:
    import win32com.client as win32  # type: ignore
except Exception:
    win32 = None


def get_dates() -> dict[str, str]:
    today = datetime.now().date()
    yesterday = today - timedelta(days=1)
    tomorrow = today + timedelta(days=1)
    return {
        "yesterday": yesterday.strftime("%Y.%m.%d"),
        "tomorrow": tomorrow.strftime("%Y.%m.%d"),
    }


CONFIG = {
    "base_url": "",
    "username": "",
    "password": "",

    # Download names (without hardcoded paths)
    "report_name_flow_1": "transaction1",
    "report_name_flow_2": "transaction2",

    # If None -> save to current working directory
    "save_dir": None,  # e.g. r"C:\Users\YOUR_USER\Downloads"

    # Email settings (Outlook)
    "email_recipients": ["recipient1@domain.com", "recipient2@domain.com"],
    "email_subject_flow_1": "Report - Flow 1",
    "email_subject_flow_2": "Report - Flow 2",
    "email_body_flow_1": "Hello,\n\nAttached is the Excel report generated by Flow 1.\n\nRegards,",
    "email_body_flow_2": "Hello,\n\nAttached is the Excel report generated by Flow 2.\n\nRegards,",
}


LAUNCH_ARGS = [
    "--disable-notifications",
    "--disable-infobars",
    "--disable-geolocation",
    "--disable-media-stream",
    "--disable-permissions-api",
    "--disable-blink-features=AutomationControlled",
]


def resolve_save_path(save_dir: str | None, filename: str) -> str:
    if not filename:
        filename = "report.xlsx"
    if "." not in filename:
        filename += ".xlsx"
    if save_dir:
        return os.path.join(save_dir, filename)
    return os.path.abspath(filename)


async def get_iframe_frame(page, iframe_name: str):
    """
    Returns the Frame object for a named iframe.
    """
    iframe_locator = page.locator(f'iframe[name="{iframe_name}"]')
    frame = await iframe_locator.content_frame()
    if frame is None:
        raise RuntimeError(f'Iframe "{iframe_name}" not found or not ready.')
    return frame


async def download_excel_from_dialog(
    page,
    iframe_name: str,
    file_name_value: str,
    ok_button_name: str = "OK",
):
    """
    Captures a browser download triggered from inside an iframe dialog, then returns:
      (suggested_filename, download_object)

    Returns None if no browser download was detected (timeout).
    """
    frame = await get_iframe_frame(page, iframe_name)

    await frame.get_by_role("textbox", name="File name").click()
    await frame.get_by_role("textbox", name="File name").fill(file_name_value)
    await frame.get_by_role("textbox", name="File name").press("Enter")

    download_task = asyncio.create_task(page.wait_for_event("download", timeout=120000))
    await frame.get_by_role("button", name=ok_button_name).click()

    try:
        download = await download_task
    except PWTimeout:
        return None

    suggested = download.suggested_filename or f"{file_name_value}.xlsx"
    return suggested, download


def send_outlook_email(to_list: list[str], subject: str, body: str, attachment_path: str) -> None:
    """
    Sends an email via Outlook desktop (Windows).
    Requires: Outlook installed + user logged in + pywin32 installed.
    """
    if win32 is None:
        raise RuntimeError("pywin32 is not available. Install it with: pip install pywin32")

    if not os.path.exists(attachment_path):
        raise FileNotFoundError(f"Attachment not found: {attachment_path}")

    outlook = win32.Dispatch("Outlook.Application")
    mail = outlook.CreateItem(0)  # 0 = MailItem
    mail.To = "; ".join(to_list)
    mail.Subject = subject
    mail.Body = body
    mail.Attachments.Add(attachment_path)
    mail.Send()


# =========================
# FLOW 1
# =========================
async def run_flow_1(playwright, config: dict) -> str | None:
    dates = get_dates()

    browser = await playwright.chromium.launch(
        headless=False,
        args=LAUNCH_ARGS,
    )
    context = await browser.new_context(
        viewport=None,
        accept_downloads=True,
        permissions=[],
    )
    page = await context.new_page()

    await page.goto(config["base_url"])

    await expect(page.get_by_role("textbox", name="Cuenta de usuario")).to_be_visible(timeout=180000)
    print("[FLOW 1] Login form visible")

    await page.get_by_role("textbox", name="Cuenta de usuario").fill(config["username"])
    await page.get_by_role("textbox", name="Contraseña").fill(config["password"])
    await page.get_by_role("button", name="Login").click()

    await expect(
        page.locator("div").filter(has_text=re.compile(r"^Production$")).first
    ).to_be_visible(timeout=900000)

    await page.get_by_role("searchbox", name="Filter").fill("Transaction1")
    await page.locator("#idLeftSide--idMenuFilter-search").click()
    try:
        await page.get_by_role("button", name="Close").click(timeout=4000)
    except PWTimeout:
        pass

    await expect(page.get_by_text("Procurement")).to_be_visible(timeout=180000)
    await page.locator("#idLeftSide--idMenuTree-rows-row1-treeicon").click()

    await expect(page.get_by_text("[3] Service Material Operation", exact=True)).to_be_visible(timeout=180000)
    await page.locator("#idLeftSide--idMenuTree-rows-row2-treeicon").click()

    await expect(page.get_by_text("Purchase of Service Material")).to_be_visible(timeout=180000)
    await page.locator("#idLeftSide--idMenuTree-rows-row3-treeicon").click()

    await expect(page.get_by_text("G/R & Movment Management")).to_be_visible(timeout=180000)
    await page.locator("#idLeftSide--idMenuTree-rows-row4-treeicon").click()

    await page.locator("div").filter(has_text=re.compile(r"^Display summarized info for xml doc$")).first.click()

    await page.get_by_title(" ", exact=True).click()

    iframe_name = "application-Shell-startGUI-iframe"
    frame = await get_iframe_frame(page, iframe_name)

    await frame.get_by_role("textbox", name="Company Code").fill("A21")
    await asyncio.sleep(0.5)
    await frame.get_by_role("textbox", name="Receiver ID").fill("company")
    await frame.get_by_role("textbox", name="Message ID").fill("entry")

    await frame.get_by_role("textbox", name="EDI Received Date Required").clear()
    await asyncio.sleep(0.3)
    await frame.get_by_role("textbox", name="EDI Received Date Required").fill(dates["yesterday"])
    await asyncio.sleep(0.3)

    await frame.get_by_role("button", name="Execute  Emphasized").click()
    await asyncio.sleep(2)

    frame_locator = page.frame_locator(f'iframe[name="{iframe_name}"]')
    scrollbar_handle = frame_locator.locator(".urSCBBtn.urBorderBox.lsScrollbar--inlineBlock")
    await scrollbar_handle.scroll_into_view_if_needed()

    box = await scrollbar_handle.bounding_box()
    if box:
        start_x = box["x"] + box["width"] / 2
        start_y = box["y"] + box["height"] / 2
        await page.mouse.move(start_x, start_y)
        await page.mouse.down()
        await page.mouse.move(start_x + 460, start_y, steps=15)
        await page.mouse.up()
        await asyncio.sleep(0.5)

    await frame_locator.locator(
        'td[role="gridcell"][lsmatrixrowindex="1"][lsmatrixcolindex="14"]'
    ).dblclick()

    saved_path = None
    try:
        result = await download_excel_from_dialog(
            page=page,
            iframe_name=iframe_name,
            file_name_value=config["report_name_flow_1"],
            ok_button_name="OK",
        )
        if result is not None:
            suggested_name, download_obj = result
            final_path = resolve_save_path(config["save_dir"], suggested_name)
            await download_obj.save_as(final_path)
            saved_path = final_path
            print("[FLOW 1] Saved:", saved_path)
        else:
            print("[FLOW 1] No browser download detected (export may be handled internally).")
    except Exception as e:
        print("[FLOW 1] Download error:", e)

    await asyncio.sleep(1)
    await browser.close()
    return saved_path


# =========================
# FLOW 2
# =========================
async def run_flow_2(playwright, config: dict) -> str | None:
    browser = await playwright.chromium.launch(
        headless=False,
        args=LAUNCH_ARGS,
    )
    context = await browser.new_context(
        viewport=None,
        accept_downloads=True,
        permissions=[],
    )
    page = await context.new_page()

    await page.goto(config["base_url"])

    await expect(page.get_by_role("textbox", name="Cuenta de usuario")).to_be_visible(timeout=180000)
    print("[FLOW 2] Login form visible")

    await page.get_by_role("textbox", name="Cuenta de usuario").fill(config["username"])
    await page.get_by_role("textbox", name="Contraseña").fill(config["password"])
    await page.get_by_role("button", name="Login").click()

    await expect(
        page.locator("div").filter(has_text=re.compile(r"^Production$")).first
    ).to_be_visible(timeout=900000)

    await page.get_by_role("searchbox", name="Filter").fill("Transaction2")
    await page.locator("#idLeftSide--idMenuFilter-search").click()

    # Replace this validation with something real from your second transaction
    try:
        await expect(page.get_by_text("Some Screen Title")).to_be_visible(timeout=120000)
        print("[FLOW 2] Target screen visible")
    except PWTimeout:
        print("[FLOW 2] Validation text not found; update the selector/text for this flow.")

    # If Flow 2 also exports, place its export steps here.
    # Below is a safe placeholder that tries the same export pattern.
    iframe_name = "application-Shell-startGUI-iframe"
    saved_path = None

    try:
        frame_locator = page.frame_locator(f'iframe[name="{iframe_name}"]')
        await frame_locator.locator(
            'td[role="gridcell"][lsmatrixrowindex="1"][lsmatrixcolindex="14"]'
        ).dblclick()

        result = await download_excel_from_dialog(
            page=page,
            iframe_name=iframe_name,
            file_name_value=config["report_name_flow_2"],
            ok_button_name="OK",
        )
        if result is not None:
            suggested_name, download_obj = result
            final_path = resolve_save_path(config["save_dir"], suggested_name)
            await download_obj.save_as(final_path)
            saved_path = final_path
            print("[FLOW 2] Saved:", saved_path)
        else:
            print("[FLOW 2] No browser download detected (export may be handled internally).")

    except Exception as e:
        print("[FLOW 2] Download error:", e)

    await asyncio.sleep(1)
    await browser.close()
    return saved_path


# =========================
# MAIN: run both flows concurrently, then email both Excel files via Outlook
# =========================
async def main():
    async with async_playwright() as p:
        flow1_task = asyncio.create_task(run_flow_1(p, CONFIG))
        flow2_task = asyncio.create_task(run_flow_2(p, CONFIG))

        flow1_file, flow2_file = await asyncio.gather(flow1_task, flow2_task)

    # Send emails after both flows finish (Outlook send is sync code)
    if win32 is None:
        print("Outlook email not sent because pywin32 is missing. Install: pip install pywin32")
        return

    if flow1_file:
        send_outlook_email(
            to_list=CONFIG["email_recipients"],
            subject=CONFIG["email_subject_flow_1"],
            body=CONFIG["email_body_flow_1"],
            attachment_path=flow1_file,
        )
        print("[EMAIL] Flow 1 email sent:", flow1_file)
    else:
        print("[EMAIL] Flow 1 email not sent: file path is empty")

    if flow2_file:
        send_outlook_email(
            to_list=CONFIG["email_recipients"],
            subject=CONFIG["email_subject_flow_2"],
            body=CONFIG["email_body_flow_2"],
            attachment_path=flow2_file,
        )
        print("[EMAIL] Flow 2 email sent:", flow2_file)
    else:
        print("[EMAIL] Flow 2 email not sent: file path is empty")


if __name__ == "__main__":
    asyncio.run(main())
